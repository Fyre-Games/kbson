/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.github.jershell.kbson

import com.github.jershell.kbson.models.*
import com.github.jershell.kbson.models.polymorph.*
import kotlinx.serialization.MissingFieldException
import kotlinx.serialization.SerializationException
import kotlinx.serialization.modules.SerializersModule
import kotlinx.serialization.modules.plus
import kotlinx.serialization.modules.serializersModuleOf
import org.bson.*
import org.bson.conversions.Bson
import kotlin.test.Test
import kotlin.test.assertEquals
import org.bson.types.Decimal128
import org.bson.types.ObjectId
import java.lang.Error
import java.math.BigDecimal
import java.util.Date
import java.util.Arrays
import kotlin.math.PI
import kotlin.test.assertTrue


class KBsonTest {
    private val kBson = KBson()

    private val ts = 1562442284934L
    val img = this::class.java.getResource("/image.png").readBytes()
    val txt = this::class.java.getResource("/lorem.txt").readBytes()
    val file = this::class.java.getResource("/MD5SUMS.zip").readBytes()

    // instance of data class
    val simpleModel = Simple(
            "value_string",
            PI,
            0.1f,
            42L,
            '€',
            true,
            42
    )
    val nestedModel = Nested(n = simpleModel, m = 42)
    val complexModel = Complex(
            Date(ts),
            Pair("FOO", "BAR"),
            listOf("foo", "bar", "baz"),
            Triple("foo", "bar", "baz"),
            mapOf("key_1" to 42, "key_2" to 24, "key_3" to 444),
            mapOf(true to "AAA", false to "BBB"),
            mapOf(2.45 to 222f, 22.11 to 333f)
    )

    val blobModel = Blob(img, txt, file)

    val blobDoc = BsonDocument().apply {
        put("img", BsonBinary(img))
        put("zipFile", BsonBinary(file))
        put("txt", BsonBinary(txt))
    }

    val strictBlobModel = Blob(
            img = img,
            txt = txt,
            zipFile = file
    )

    val strictBlobDoc = BsonDocument().apply {
        put("img", BsonBinary(img))
        put("txt", BsonBinary(txt))
        put("zipFile", BsonBinary(file))
    }

    val complexDoc = BsonDocument().apply {
        put("createAt", BsonDateTime(ts))
        put("pair", BsonDocument().apply {
            put("first", BsonString("FOO"))
            put("second", BsonString("BAR"))
        })
        put("list", BsonArray(listOf(
                BsonString("foo"),
                BsonString("bar"),
                BsonString("baz")
        )))
        put("triple", BsonDocument().apply {
            put("first", BsonString("foo"))
            put("second", BsonString("bar"))
            put("third", BsonString("baz"))
        })
        put("map", BsonDocument().apply {
            put("key_1", BsonInt32(42))
            put("key_2", BsonInt32(24))
            put("key_3", BsonInt32(444))
        })
        put("booleanMap", BsonDocument().apply {
            put("true", BsonString("AAA"))
            put("false", BsonString("BBB"))
        })
        put("doubleFloatMap", BsonDocument().apply {
            put("2.45", BsonDouble(222.0))
            put("22.11", BsonDouble(333.0))
        })
    }

    // source document in bson
    val simpleDoc = BsonDocument().apply {
        put("valueDouble", BsonDouble(PI))
        put("valueString", BsonString("value_string"))
        put("valueFloat", BsonDouble(0.1f.toDouble()))
        put("valueInt", BsonInt32(42))
        put("valueLong", BsonInt64(42L))
        put("valueChar", BsonSymbol('€'.toString()))
        put("valueBool", BsonBoolean(true))
    }

    val strictSimpleDoc = BsonDocument().apply {
        put("valueString", BsonString("value_string"))
        put("valueDouble", BsonDouble(PI))
        put("valueFloat", BsonDouble(0.1f.toDouble()))
        put("valueLong", BsonInt64(42L))
        put("valueChar", BsonSymbol('€'.toString()))
        put("valueBool", BsonBoolean(true))
        put("valueInt", BsonInt32(42))
    }

    val nestedDoc = BsonDocument().apply {
        put("m", BsonInt32(42))
        put("n", simpleDoc)
    }

    val strictNestedDoc = BsonDocument().apply {
        put("n", strictSimpleDoc)
        put("m", BsonInt32(42))
    }


    val nestedComplex = NestedComplex(
            mapOf(
                    10.toByte() to mapOf(
                            '€' to SimpleNG(87, listOf('‡', '↪', '@', '$')),
                            '$' to SimpleNG(88, listOf('!', '?', '~', '='))
                    ),
                    11.toByte() to mapOf(
                            '€' to SimpleNG(89, listOf('‡', '↪', '@', '$')),
                            '$' to SimpleNG(90, listOf('!', '?', '~', '='))
                    )
            ),
            listOf(
                    mapOf(
                            40 to listOf(31, 32, 33, 34, 35),
                            41 to listOf(31, 32, 33, 34, 35)
                    ),
                    mapOf(
                            40 to listOf(1, 3, 3, 4, 5),
                            41 to listOf(31, 32, 33, 34, 35)
                    ),
                    mapOf(
                            40 to listOf(0, 0, 1, 4, 5),
                            41 to listOf(31, 32, 33, 34, 35)
                    ),
                    mapOf(
                            40 to listOf(11, 31, 31, 41, 51),
                            41 to listOf(31, 32, 33, 34, 35)
                    ),
                    mapOf(
                            44 to listOf(1, 33, 33, 44, 55),
                            41 to listOf(31, 32, 33, 34, 35)
                    )
            )
    )

    val nestedComplexDoc = BsonDocument().apply {
        put("mapOfMaps", BsonDocument().apply {
            put("10", BsonDocument().apply {
                put("€", BsonDocument().apply {
                    put("short", BsonInt32(87))
                    put("list", BsonArray(listOf(BsonSymbol("‡"), BsonSymbol("↪"), BsonSymbol("@"), BsonSymbol("$"))))
                })
                put("$", BsonDocument().apply {
                    put("short", BsonInt32(88))
                    put("list", BsonArray(listOf(BsonSymbol("!"), BsonSymbol("?"), BsonSymbol("~"), BsonSymbol("="))))
                })
            })
            put("11", BsonDocument().apply {
                put("€", BsonDocument().apply {
                    put("short", BsonInt32(89))
                    put("list", BsonArray(listOf(BsonSymbol("‡"), BsonSymbol("↪"), BsonSymbol("@"), BsonSymbol("$"))))
                })
                put("$", BsonDocument().apply {
                    put("short", BsonInt32(90))
                    put("list", BsonArray(listOf(BsonSymbol("!"), BsonSymbol("?"), BsonSymbol("~"), BsonSymbol("="))))
                })
            })
        })

        put("listOfMaps", BsonArray(
                listOf(
                        BsonDocument().apply {
                            put("40", BsonArray(listOf(BsonInt32(31), BsonInt32(32), BsonInt32(33), BsonInt32(34), BsonInt32(35))))
                            put("41", BsonArray(listOf(BsonInt32(31), BsonInt32(32), BsonInt32(33), BsonInt32(34), BsonInt32(35))))
                        },
                        BsonDocument().apply {
                            put("40", BsonArray(listOf(BsonInt32(1), BsonInt32(3), BsonInt32(3), BsonInt32(4), BsonInt32(5))))
                            put("41", BsonArray(listOf(BsonInt32(31), BsonInt32(32), BsonInt32(33), BsonInt32(34), BsonInt32(35))))
                        },
                        BsonDocument().apply {
                            put("40", BsonArray(listOf(BsonInt32(0), BsonInt32(0), BsonInt32(1), BsonInt32(4), BsonInt32(5))))
                            put("41", BsonArray(listOf(BsonInt32(31), BsonInt32(32), BsonInt32(33), BsonInt32(34), BsonInt32(35))))
                        },
                        BsonDocument().apply {
                            put("40", BsonArray(listOf(BsonInt32(11), BsonInt32(31), BsonInt32(31), BsonInt32(41), BsonInt32(51))))
                            put("41", BsonArray(listOf(BsonInt32(31), BsonInt32(32), BsonInt32(33), BsonInt32(34), BsonInt32(35))))
                        },
                        BsonDocument().apply {
                            put("44", BsonArray(listOf(BsonInt32(1), BsonInt32(33), BsonInt32(33), BsonInt32(44), BsonInt32(55))))
                            put("41", BsonArray(listOf(BsonInt32(31), BsonInt32(32), BsonInt32(33), BsonInt32(34), BsonInt32(35))))
                        }

                )))
    }

    @Test
    fun simpleDocStringify() {
        assertEquals(simpleDoc, kBson.stringify(Simple.serializer(), simpleModel))
    }

    @Test
    fun simpleDocParseTest() {
        assertEquals(simpleModel, kBson.parse(Simple.serializer(), simpleDoc))
    }

    @Test
    fun nestedParse() {
        val res = kBson.parse(Nested.serializer(), nestedDoc)
        assertEquals(nestedModel, res)
    }

    @Test
    fun nestedStringify() {
        val d = nestedDoc
        val res = kBson.stringify(Nested.serializer(), nestedModel)
        assertEquals(d, res)
    }

    @Test
    fun complexStringify() {
        val expected = complexDoc
        val actual = kBson.stringify(Complex.serializer(), complexModel)
        assertEquals(expected, actual)
    }

    @Test
    fun complexParse() {
        val result = kBson.parse(Complex.serializer(), complexDoc)
        assertEquals(complexModel, result)
    }

    @Test
    fun nestedComplex() {
        val result: NestedComplex = kBson.parse(
                NestedComplex.serializer(),
                nestedComplexDoc
        )
        assertEquals(nestedComplex, result)
    }

    @Test
    fun nestedComplexStringify() {
        val result = kBson.stringify(NestedComplex.serializer(), nestedComplex)
        assertEquals(nestedComplexDoc, result)
    }

    @Test
    fun nestedComplexStringifyAndParse() {
        val tmp = kBson.stringify(NestedComplex.serializer(), nestedComplex)
        val result: NestedComplex = kBson.parse(NestedComplex.serializer(), tmp)
        assertEquals(nestedComplex, result)
    }

    @Test
    fun customTypesStringify() {
        val custom = Custom(ObjectId("5d17ab793b4083d41f829821"), BigDecimal("3.14"))
        val actual = kBson.stringify(Custom.serializer(), custom)
        val expectedCustomDoc = BsonDocument().apply {
            put("_id", BsonObjectId(ObjectId("5d17ab793b4083d41f829821")))
            put("dec128", BsonDecimal128(Decimal128(BigDecimal("3.14"))))
        }
        assertEquals(
                expectedCustomDoc,
                actual
        )
    }

    @Test
    fun objectId() {
        val custom = Custom(dec128 = BigDecimal("3.14"))
        val actual = kBson.stringify(Custom.serializer(), custom)
        val expectedCustomDoc = BsonDocument().apply {
            put("dec128", BsonDecimal128(Decimal128(BigDecimal("3.14"))))
        }
        assertEquals(
                expectedCustomDoc,
                actual
        )
    }

    @Test
    fun pairStringify() {
        val wp = WithPair(
                Pair(null, "value"),
                Triple(
                        42,
                        null,
                        2L
                )
        )
        val expected = BsonDocument().apply {
            put("pair", BsonDocument().apply {
                put("first", BsonNull())
                put("second", BsonString("value"))

            })
            put("triple", BsonDocument().apply {
                put("first", BsonInt32(42))
                put("second", BsonNull())
                put("third", BsonInt64(2L))
            })
        }
        val actual = kBson.stringify(WithPair.serializer(), wp)

        assertEquals(
                expected,
                actual
        )
    }

    @Test
    fun objectIdStringify() {
        val childEntity = ChildEntity(userId = "5d17ab793b4083d41f829821")
        childEntity.updatedAt = Date()
        val actual = kBson.stringify(ChildEntity.serializer(), childEntity)

        val expected = BsonDocument().apply {
            put("userId", BsonString("5d17ab793b4083d41f829821"))
            put("createdAt", BsonNull())
            put("updatedAt", BsonDateTime(childEntity.updatedAt!!.time))
        }

        assertEquals(
                expected,
                actual
        )
    }

    @Test
    fun customTypesParse() {
        val expectedCustom = Custom(ObjectId("5d17ab793b4083d41f829821"), BigDecimal("3.14"))

        val customBsonDoc = BsonDocument().apply {
            put("_id", BsonObjectId(ObjectId("5d17ab793b4083d41f829821")))
            put("dec128", BsonDecimal128(Decimal128(BigDecimal("3.14"))))
        }

        val actualCustom = kBson.parse(Custom.serializer(), customBsonDoc)

        assertEquals(
                expectedCustom,
                actualCustom
        )
    }

    @Test
    fun blobStringify() {
        assertEquals(
                kBson.stringify(Blob.serializer(), blobModel),
                blobDoc
        )
    }

    @Test
    fun blobParse() {
        val expectedResult = blobModel
        val result = kBson.parse(Blob.serializer(), blobDoc)
        assertTrue(
                Arrays.equals(expectedResult.img, result.img) &&
                        Arrays.equals(expectedResult.txt, result.txt) &&
                        Arrays.equals(expectedResult.zipFile, result.zipFile)
        )
    }

    @Test
    fun optionalParse() {
        val badDoc = BsonDocument().apply {
            put("reqString3", BsonString("reqString3"))
        }
        val result = kBson.parse(OptionalClass.serializer(), badDoc)
        assertTrue(
                (result.reqString == "default_value1") &&
                        (result.reqString3 == "reqString3")
        )
    }

    @Test
    fun optionalStringify() {
        val data = OptionalClass(reqString3 = "foo")

        val doc = BsonDocument().apply {
            put("reqString", BsonString("default_value1"))
            put("reqString3", BsonString("foo"))
        }
        val result = kBson.stringify(OptionalClass.serializer(), data)
        assertEquals(doc, result)
    }

    @Test
    fun exceptionsMissingValue() {
        val docBadType = BsonDocument()

        try {
            kBson.parse(SimpleNG.serializer(), docBadType)
        } catch (e: MissingFieldException) {
            assertTrue(e.message == "Field 'short' is required, but it was missing")
        }
    }

    @Test
    fun exceptionsBadType() {
        val docBadType = BsonDocument().apply {
            put("short", BsonString("127"))
        }

        try {
            kBson.parse(SimpleNG.serializer(), docBadType)
        } catch (e: BsonInvalidOperationException) {
            assertTrue(e.message == "Value expected to be of type INT32 is of unexpected type STRING")
        }
    }

    @Test
    fun nullParseTest() {
        val docNullableField = BsonDocument().apply {
            put("str", BsonNull())
        }
        val docField = BsonDocument().apply {
            put("str", BsonString("exist"))
        }

        val result1 = kBson.parse(NullableClass.serializer(), docNullableField)
        val result2 = kBson.parse(NullableClass.serializer(), docField)
        assertTrue(result1.str == null && result2.str == "exist")
    }

    @Test
    fun nonFieldParse() {
        val doc = BsonDocument()
        val value = NullableDefaultClass()
        assertEquals(value, kBson.parse(NullableDefaultClass.serializer(), doc))
    }

    @Test
    fun nullStringifyTest() {
        val docNullableField = BsonDocument().apply {
            put("str", BsonNull())
        }

        val modelNullableField = NullableClass(null)

        val docField = BsonDocument().apply {
            put("str", BsonString("exist"))
        }

        val modelField = NullableClass("exist")

        val result1 = kBson.stringify(NullableClass.serializer(), modelNullableField)
        val result2 = kBson.stringify(NullableClass.serializer(), modelField)

        assert(
                docNullableField.equals(result1) &&
                        docField.equals(result2)
        )
    }

    @Test
    fun maps() {
        val foo = Foo(
                key_A = mapOf("a" to "a", "b" to "b", "c" to "c", "d" to "d", "e" to "e"),
                key_B = mapOf("a" to "a", "b" to "b", "c" to "c", "d" to "d", "e" to "e"))

        val doc = BsonDocument().apply {
            put("key_A", BsonDocument().apply {
                put("a", BsonString("a"))
                put("b", BsonString("b"))
                put("c", BsonString("c"))
                put("d", BsonString("d"))
                put("e", BsonString("e"))
            })
            put("key_B", BsonDocument().apply {
                put("a", BsonString("a"))
                put("b", BsonString("b"))
                put("c", BsonString("c"))
                put("d", BsonString("d"))
                put("e", BsonString("e"))
            })
        }
        val result = kBson.parse(Foo.serializer(), doc)
        assertEquals(foo, result)
    }

    @Test
    fun enumStringify() {
        val model = EnumFoo(
                sex = SEX.FEMALE,
                sex2 = SexWithValue.TRANSGENDER
        )

        val result = kBson.stringify(EnumFoo.serializer(), model)

        assertEquals(BsonDocument().apply {
            put("sex", BsonString("FEMALE"))
            put("sex2", BsonString("TRANSGENDER"))
        }, result)
    }

    @Test
    fun enumParse() {
        val model = EnumFoo(
                sex = SEX.FEMALE,
                sex2 = SexWithValue.TRANSGENDER
        )

        val doc = BsonDocument().apply {
            put("sex", BsonString("FEMALE"))
            put("sex2", BsonString("TRANSGENDER"))
        }
        val result = kBson.parse(EnumFoo.serializer(), doc)
        assertEquals(result, model)
    }

    @Test
    fun enumParseException() {
        val doc = BsonDocument().apply {
            put("sex", BsonString("FEMALE"))
            put("sex2", BsonString("AGENDER"))
        }

        try {
            kBson.parse(EnumFoo.serializer(), doc)
        } catch (e: SerializationException) {
            assertEquals("Enum has unknown value AGENDER", e.message)
        }
    }

    @Test
    fun mapValueParse() {
        val a = NestedMap("AAA", mapOf(
                "key" to Value("val1", listOf("val2", "val3"))
        ))

        val b = BsonDocument().apply {
            append("name", BsonString("AAA"))
            append("map", BsonDocument().apply {
                append("key", BsonDocument().apply {
                    append("value1", BsonString("val1"))
                    append("value2", BsonArray().apply {
                        add(BsonString("val2"))
                        add(BsonString("val3"))
                    })
                })
            })
        }

        assertEquals(a, kBson.parse(NestedMap.serializer(), b))
    }

    @Test
    fun loadSimpleDoc() {
        val result = kBson.load(Simple.serializer(), strictSimpleDoc)
        assertEquals(simpleModel, result)
    }

    @Test
    fun loadNested() {
        val res = kBson.load(Nested.serializer(), strictNestedDoc)
        assertEquals(nestedModel, res)
    }

    @Test
    fun loadComplex() {
        val result = kBson.load(Complex.serializer(), complexDoc.toByteArray())
        assertEquals(complexModel, result)
    }

    @Test
    fun nestedComplexDumpAndLoad() {
        val tmp = kBson.dump(NestedComplex.serializer(), nestedComplex)
        val result: NestedComplex = kBson.load(NestedComplex.serializer(), tmp)
        assertEquals(nestedComplex, result)
    }

    @Test
    fun customTypesLoad() {
        val expectedCustom = Custom(ObjectId("5d17ab793b4083d41f829821"), BigDecimal("3.14"))

        val customBsonDoc = BsonDocument().apply {
            put("_id", BsonObjectId(ObjectId("5d17ab793b4083d41f829821")))
            put("dec128", BsonDecimal128(Decimal128(BigDecimal("3.14"))))
        }.toByteArray()

        val actualCustom = kBson.load(Custom.serializer(), customBsonDoc)

        assertEquals(
                expectedCustom,
                actualCustom
        )
    }

    @Test
    fun blobLoad() {
        val expectedResult = strictBlobModel
        val result = kBson.load(Blob.serializer(), strictBlobDoc.toByteArray())
        assertTrue(
                Arrays.equals(expectedResult.img, result.img) &&
                        Arrays.equals(expectedResult.txt, result.txt) &&
                        Arrays.equals(expectedResult.zipFile, result.zipFile)
        )
    }

    @Test
    fun optionalLoad() {
        val badDoc = BsonDocument().apply {
            put("reqString3", BsonString("reqString3"))
        }
        val result = kBson.load(OptionalClass.serializer(), badDoc)
        assertTrue(
                (result.reqString == "default_value1") &&
                        (result.reqString3 == "reqString3")
        )
    }

    @Test
    fun loadNullTest() {
        val docNullableField = BsonDocument().apply {
            put("str", BsonNull())
        }
        val docField = BsonDocument().apply {
            put("str", BsonString("exist"))
        }

        val result1 = kBson.load(NullableClass.serializer(), docNullableField)
        val result2 = kBson.load(NullableClass.serializer(), docField)
        assertTrue(result1.str == null && result2.str == "exist")
    }

    @Test
    fun loadNonField() {
        val doc = BsonDocument()
        val value = NullableDefaultClass()
        assertEquals(value, kBson.load(NullableDefaultClass.serializer(), doc))
    }

    @Test
    fun loadMaps() {
        val foo = Foo(
                key_A = mapOf("a" to "a", "b" to "b", "c" to "c", "d" to "d", "e" to "e"),
                key_B = mapOf("a" to "a", "b" to "b", "c" to "c", "d" to "d", "e" to "e"))

        val doc = BsonDocument().apply {
            put("key_A", BsonDocument().apply {
                put("a", BsonString("a"))
                put("b", BsonString("b"))
                put("c", BsonString("c"))
                put("d", BsonString("d"))
                put("e", BsonString("e"))
            })
            put("key_B", BsonDocument().apply {
                put("a", BsonString("a"))
                put("b", BsonString("b"))
                put("c", BsonString("c"))
                put("d", BsonString("d"))
                put("e", BsonString("e"))
            })
        }
        val result = kBson.load(Foo.serializer(), doc)
        assertEquals(foo, result)
    }

    @Test
    fun loadEnum() {
        val model = EnumFoo(
                sex = SEX.FEMALE,
                sex2 = SexWithValue.TRANSGENDER
        )

        val doc = BsonDocument().apply {
            put("sex", BsonString("FEMALE"))
            put("sex2", BsonString("TRANSGENDER"))
        }
        val result = kBson.load(EnumFoo.serializer(), doc)
        assertEquals(result, model)
    }

    @Test
    fun loadEnumException() {
        val doc = BsonDocument().apply {
            put("sex", BsonString("FEMALE"))
            put("sex2", BsonString("AGENDER"))
        }

        try {
            kBson.load(EnumFoo.serializer(), doc.toByteArray())
        } catch (e: SerializationException) {
            assertEquals("Enum has unknown value AGENDER", e.message)
        }
    }

    @Test
    fun loadMapValue() {
        val a = NestedMap("AAA", mapOf(
                "key" to Value("val1", listOf("val2", "val3"))
        ))

        val b = BsonDocument().apply {
            append("name", BsonString("AAA"))
            append("map", BsonDocument().apply {
                append("key", BsonDocument().apply {
                    append("value1", BsonString("val1"))
                    append("value2", BsonArray().apply {
                        add(BsonString("val2"))
                        add(BsonString("val3"))
                    })
                })
            })
        }

        assertEquals(a, kBson.load(NestedMap.serializer(), b))
    }

    @Test
    fun parseNullableCollection() {
        val bsonDocument = BsonDocument().apply {
            append("fieldNull", BsonNull())
            append("list", BsonArray().apply {
                add(BsonString("v1"))
                add(BsonNull())
                add(BsonNull())
                add(BsonString("v4"))
            })
            append("map", BsonDocument().apply {
                append("k1", BsonNull())
                append("k2", BsonInt32(42))
                append("k3", BsonInt32(44))
            })
        }

        val collection = NullableCollection(
                null,
                listOf("v1", null, null, "v4"),
                mapOf(
                        "k1" to null,
                        "k2" to 42,
                        "k3" to 44
                )
        )

        assertEquals(collection, kBson.parse(NullableCollection.serializer(), bsonDocument))
    }

    @Test
    fun loadNullableCollection() {
        val expected = BsonDocument().apply {
            append("fieldNull", BsonNull())
            append("list", BsonArray().apply {
                add(BsonString("v1"))
                add(BsonNull())
                add(BsonNull())
                add(BsonString("v4"))
            })
            append("map", BsonDocument().apply {
                append("k1", BsonNull())
                append("k2", BsonInt32(42))
                append("k3", BsonInt32(44))
            })
        }

        val collection = NullableCollection(
                null,
                listOf("v1", null, null, "v4"),
                mapOf("k1" to null, "k2" to 42, "k3" to 44)
        )

        assertEquals(collection, kBson.load(NullableCollection.serializer(), expected))
    }

    @Test
    fun loadBinNullableCollection() {
        val expected = BsonDocument().apply {
            append("fieldNull", BsonNull())
            append("list", BsonArray().apply {
                add(BsonString("v1"))
                add(BsonNull())
                add(BsonNull())
                add(BsonString("v4"))
            })
            append("map", BsonDocument().apply {
                append("k1", BsonNull())
                append("k2", BsonInt32(42))
                append("k3", BsonInt32(44))
            })
        }.toByteArray()

        val collection = NullableCollection(
                null,
                listOf("v1", null, null, "v4"),
                mapOf("k1" to null, "k2" to 42, "k3" to 44)
        )

        assertEquals(collection, kBson.load(NullableCollection.serializer(), expected))
    }

    @Test
    fun loadExceptionsMissingValue() {
        val docBadType = BsonDocument().apply {
            append("f1", BsonInt32(1))
            append("f2", BsonInt32(2))
            append("f3", BsonInt32(3))
        }

        try {
            kBson.load(SimpleNG.serializer(), docBadType)
        } catch (e: MissingFieldException) {
            assertTrue(e.message == "Field 'short' is required, but it was missing")
        }
    }

    @Test
    fun loadExceptionsBadType() {
        val docBadType = BsonDocument().apply {
            put("short", BsonString("127"))
        }

        try {
            kBson.load(SimpleNG.serializer(), docBadType)
        } catch (e: BsonInvalidOperationException) {
            assertTrue(e.message == "readInt32 can only be called when CurrentBSONType is INT32, not when CurrentBSONType is STRING.")
        }
    }

    @Test
    fun stringifyPolymorphism() {
        val pModule = SerializersModule {
            polymorphic(Message::class) {
                StringMessage::class with StringMessage.serializer()
                IntMessage::class with IntMessage.serializer()
            }
        }
        val conf = Configuration()
        val mDoc = BsonDocument().apply {
            append("m", BsonDocument().apply {
                append(conf.classDiscriminator, BsonString("com.github.jershell.kbson.models.polymorph.StringMessage"))
                append("msg", BsonString("FortyTwo"))
            })
        }

        val nDoc = BsonDocument().apply {
            append("m", BsonDocument().apply {
                append(conf.classDiscriminator, BsonString("com.github.jershell.kbson.models.polymorph.IntMessage"))
                append("number", BsonInt32(42))
            })
        }

        val polyBson = KBson(context = DefaultModule + pModule)
        val res1 = polyBson.stringify(MessageWrapper.serializer(), MessageWrapper(m = StringMessage("FortyTwo")))
        val res2 = polyBson.stringify(MessageWrapper.serializer(), MessageWrapper(m = IntMessage(42)))

        assertEquals(res1, mDoc)
        assertEquals(res2, nDoc)
    }

    @Test
    fun parsePolymorphism() {
        val pModule = SerializersModule {
            polymorphic(Message::class) {
                StringMessage::class with StringMessage.serializer()
                IntMessage::class with IntMessage.serializer()
            }
        }

        val sDoc = BsonDocument().apply {
            append("m", BsonDocument().apply {
                append(Configuration().classDiscriminator, BsonString("com.github.jershell.kbson.models.polymorph.StringMessage"))
                append("msg", BsonString("FortyTwo"))
            })
        }

        val nDoc = BsonDocument().apply {
            append("m", BsonDocument().apply {
                append(Configuration().classDiscriminator, BsonString("com.github.jershell.kbson.models.polymorph.IntMessage"))
                append("number", BsonInt32(42))
            })
        }

        val polyBson = KBson(context = DefaultModule + pModule)
        val res1 = polyBson.parse(MessageWrapper.serializer(), sDoc)
        val res2 = polyBson.parse(MessageWrapper.serializer(), nDoc)

        assertEquals(MessageWrapper(m = StringMessage("FortyTwo")), res1)
        assertEquals(MessageWrapper(m = IntMessage(42)), res2)
    }

    @Test
    fun stringifyPolymorphismComplexHierarchies() {
        val pModule = SerializersModule {
            polymorphic(Message::class, TimestampedMessage::class) {
                FooTimestampedMessage::class with FooTimestampedMessage.serializer()
                StringMessage::class with StringMessage.serializer()
                IntMessage::class with IntMessage.serializer()
            }
        }
        val conf = Configuration()
        val mDoc = BsonDocument().apply {
            append("request", BsonDocument().apply {
                append(conf.classDiscriminator, BsonString("com.github.jershell.kbson.models.polymorph.StringMessage"))
                append("msg", BsonString("FortyTwo"))
            })
            append("response", BsonDocument().apply {
                append(conf.classDiscriminator, BsonString("com.github.jershell.kbson.models.polymorph.FooTimestampedMessage"))
                append("timestamp", BsonInt32(1570459730))
            })
        }

        val nDoc = BsonDocument().apply {
            append("request", BsonDocument().apply {
                append(conf.classDiscriminator, BsonString("com.github.jershell.kbson.models.polymorph.IntMessage"))
                append("number", BsonInt32(42))
            })
            append("response", BsonDocument().apply {
                append(conf.classDiscriminator, BsonString("com.github.jershell.kbson.models.polymorph.FooTimestampedMessage"))
                append("timestamp", BsonInt32(1570459730))
            })
        }

        val polyBson = KBson(context = DefaultModule + pModule)
        val res1 = polyBson.stringify(Wrapper.serializer(), Wrapper(
                request = StringMessage("FortyTwo"),
                response = FooTimestampedMessage(1570459730)
        ))
        val res2 = polyBson.stringify(Wrapper.serializer(), Wrapper(
                request = IntMessage(42),
                response = FooTimestampedMessage(1570459730)
        ))

        assertEquals(res1, mDoc)
        assertEquals(res2, nDoc)
    }

    @Test
    fun parsePolymorphismComplexHierarchies() {
        val pModule = SerializersModule {
            polymorphic(Message::class, TimestampedMessage::class) {
                FooTimestampedMessage::class with FooTimestampedMessage.serializer()
                StringMessage::class with StringMessage.serializer()
                IntMessage::class with IntMessage.serializer()
            }
        }
        val conf = Configuration()
        val mDoc = BsonDocument().apply {
            append("request", BsonDocument().apply {
                append(conf.classDiscriminator, BsonString("com.github.jershell.kbson.models.polymorph.StringMessage"))
                append("msg", BsonString("FortyTwo"))
            })
            append("response", BsonDocument().apply {
                append(conf.classDiscriminator, BsonString("com.github.jershell.kbson.models.polymorph.FooTimestampedMessage"))
                append("timestamp", BsonInt32(1570459730))
            })
        }

        val nDoc = BsonDocument().apply {
            append("request", BsonDocument().apply {
                append(conf.classDiscriminator, BsonString("com.github.jershell.kbson.models.polymorph.IntMessage"))
                append("number", BsonInt32(42))
            })
            append("response", BsonDocument().apply {
                append(conf.classDiscriminator, BsonString("com.github.jershell.kbson.models.polymorph.FooTimestampedMessage"))
                append("timestamp", BsonInt32(1570459730))
            })
        }

        val polyBson = KBson(context = DefaultModule + pModule)

        val res1 = polyBson.parse(Wrapper.serializer(), mDoc)
        val res2 = polyBson.parse(Wrapper.serializer(), nDoc)

        assertEquals(Wrapper(
                request = StringMessage("FortyTwo"),
                response = FooTimestampedMessage(1570459730)
        ), res1)

        assertEquals(Wrapper(
                request = IntMessage(42),
                response = FooTimestampedMessage(1570459730)
        ), res2)
    }

    @Test
    fun stringifyPolymorphismSealed() {
        val pModule = SerializersModule {
            polymorphic<SMessage> {
                SMessage.Error::class with SMessage.Error.serializer()
                SMessage.Loading::class with SMessage.Loading.serializer()
                SMessage.Data::class with SMessage.Data.serializer()
            }
        }
        val conf = Configuration()

        val doc1 = BsonDocument().apply {
            append("payload", BsonDocument().apply {
                append(conf.classDiscriminator, BsonString("com.github.jershell.kbson.models.polymorph.SMessage.Error"))
            })
        }

        val doc2 = BsonDocument().apply {
            append("payload", BsonDocument().apply {
                append(conf.classDiscriminator, BsonString("com.github.jershell.kbson.models.polymorph.SMessage.Loading"))
            })
        }

        val doc3 = BsonDocument().apply {
            append("payload", BsonDocument().apply {
                append(conf.classDiscriminator, BsonString("com.github.jershell.kbson.models.polymorph.SMessage.Data"))
                append("someData", BsonString("something"))
            })
        }

        val polyBson = KBson(context = DefaultModule + pModule)

        val res1 = polyBson.stringify(SealedWrapper.serializer(), SealedWrapper(
                payload = SMessage.Error()
        ))

        val res2 = polyBson.stringify(SealedWrapper.serializer(), SealedWrapper(
                payload = SMessage.Loading()
        ))

        val res3 = polyBson.stringify(SealedWrapper.serializer(), SealedWrapper(
                payload = SMessage.Data(someData = "something")
        ))

        assertEquals(res1, doc1)
        assertEquals(res2, doc2)
        assertEquals(res3, doc3)
    }

    @Test
    fun parsePolymorphismSealed() {
        val pModule = SerializersModule {
            polymorphic<SMessage> {
                SMessage.Error::class with SMessage.Error.serializer()
                SMessage.Loading::class with SMessage.Loading.serializer()
                SMessage.Data::class with SMessage.Data.serializer()
            }
        }
        val conf = Configuration()


        val doc1 = BsonDocument().apply {
            append("payload", BsonDocument().apply {
                append(conf.classDiscriminator, BsonString("com.github.jershell.kbson.models.polymorph.SMessage.Error"))
            })
        }

        val doc2 = BsonDocument().apply {
            append("payload", BsonDocument().apply {
                append(conf.classDiscriminator, BsonString("com.github.jershell.kbson.models.polymorph.SMessage.Loading"))
            })
        }

        val doc3 = BsonDocument().apply {
            append("payload", BsonDocument().apply {
                append(conf.classDiscriminator, BsonString("com.github.jershell.kbson.models.polymorph.SMessage.Data"))
                append("someData", BsonString("something"))
            })
        }

        val polyBson = KBson(context = DefaultModule + pModule)

        val res1 = polyBson.parse(SealedWrapper.serializer(), doc1)

        val res2 = polyBson.parse(SealedWrapper.serializer(), doc2)

        val res3 = polyBson.parse(SealedWrapper.serializer(), doc3)

        assertTrue(res1.payload is SMessage.Error)
        assertTrue(res2.payload is SMessage.Loading)
        assertTrue(res3.payload is SMessage.Data && res3.payload.someData == "something")
    }
}
