/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.github.jershell.kbson

import com.github.jershell.kbson.models.*
import kotlinx.serialization.MissingFieldException
import kotlinx.serialization.SerializationException
import org.bson.*
import kotlin.test.Test
import kotlin.test.assertEquals
import org.bson.types.Decimal128
import org.bson.types.ObjectId
import java.math.BigDecimal
import java.util.*
import kotlin.math.PI
import kotlin.test.assertTrue


class KBsonTest {
    private val kBson = KBson()
    private val ts = 1562442284934L
    val img = this::class.java.getResource("/image.png").readBytes()
    val txt = this::class.java.getResource("/lorem.txt").readBytes()
    val file = this::class.java.getResource("/MD5SUMS.zip").readBytes()

    // instance of data class
    val simpleModel = Simple(
            "value_string",
            PI,
            0.1f,
            42L,
            '€',
            true,
            42
    )
    val nestedModel = Nested(n = simpleModel, m = 42)
    val complexModel = Complex(
            Date(ts),
            Pair("FOO", "BAR"),
            listOf("foo", "bar", "baz"),
            Triple("foo", "bar", "baz"),
            mapOf("key_1" to 42, "key_2" to 24, "key_3" to 444),
            mapOf(true to "AAA", false to "BBB"),
            mapOf(2.45 to 222f, 22.11 to 333f)
    )

    val blobModel = Blob(img, txt, file)

    val blobDoc = BsonDocument().apply {
        put("img", BsonBinary(img))
        put("zipFile", BsonBinary(file))
        put("txt", BsonBinary(txt))
    }

    val complexDoc = BsonDocument().apply {
        put("createAt", BsonDateTime(ts))
        put("pair", BsonDocument().apply {
            put("first", BsonString("FOO"))
            put("second", BsonString("BAR"))
        })
        put("list", BsonArray(listOf(
                BsonString("foo"),
                BsonString("bar"),
                BsonString("baz")
        )))
        put("triple", BsonDocument().apply {
            put("first", BsonString("foo"))
            put("second", BsonString("bar"))
            put("third", BsonString("baz"))
        })
        put("map", BsonDocument().apply {
            put("key_1", BsonInt32(42))
            put("key_2", BsonInt32(24))
            put("key_3", BsonInt32(444))
        })
        put("booleanMap", BsonDocument().apply {
            put("true", BsonString("AAA"))
            put("false", BsonString("BBB"))
        })
        put("doubleFloatMap", BsonDocument().apply {
            put("2.45", BsonDouble(222.0))
            put("22.11", BsonDouble(333.0))
        })
    }

    // source document in bson
    val simpleDoc = BsonDocument().apply {
        put("valueDouble", BsonDouble(PI))
        put("valueString", BsonString("value_string"))
        put("valueFloat", BsonDouble(0.1f.toDouble()))
        put("valueInt", BsonInt32(42))
        put("valueLong", BsonInt64(42L))
        put("valueChar", BsonSymbol('€'.toString()))
        put("valueBool", BsonBoolean(true))
    }

    val nestedDoc = BsonDocument().apply {
        put("m", BsonInt32(42))
        put("n", simpleDoc)
    }


    val nestedComplex = NestedComplex(
            mapOf(
                    10.toByte() to mapOf(
                            '€' to SimpleNG(87, listOf('‡', '↪', '@', '$')),
                            '$' to SimpleNG(88, listOf('!', '?', '~', '='))
                    ),
                    11.toByte() to mapOf(
                            '€' to SimpleNG(89, listOf('‡', '↪', '@', '$')),
                            '$' to SimpleNG(90, listOf('!', '?', '~', '='))
                    )
            ),
            listOf(
                    mapOf(
                            40 to listOf(31, 32, 33, 34, 35),
                            41 to listOf(31, 32, 33, 34, 35)
                    ),
                    mapOf(
                            40 to listOf(1, 3, 3, 4, 5),
                            41 to listOf(31, 32, 33, 34, 35)
                    ),
                    mapOf(
                            40 to listOf(0, 0, 1, 4, 5),
                            41 to listOf(31, 32, 33, 34, 35)
                    ),
                    mapOf(
                            40 to listOf(11, 31, 31, 41, 51),
                            41 to listOf(31, 32, 33, 34, 35)
                    ),
                    mapOf(
                            44 to listOf(1, 33, 33, 44, 55),
                            41 to listOf(31, 32, 33, 34, 35)
                    )
            )
    )

    val nestedComplexDoc = BsonDocument().apply {
        put("mapOfMaps", BsonDocument().apply {
            put("10", BsonDocument().apply {
                put("€", BsonDocument().apply {
                    put("short", BsonInt32(87))
                    put("list", BsonArray(listOf(BsonSymbol("‡"), BsonSymbol("↪"), BsonSymbol("@"), BsonSymbol("$"))))
                })
                put("$", BsonDocument().apply {
                    put("short", BsonInt32(88))
                    put("list", BsonArray(listOf(BsonSymbol("!"), BsonSymbol("?"), BsonSymbol("~"), BsonSymbol("="))))
                })
            })
            put("11", BsonDocument().apply {
                put("€", BsonDocument().apply {
                    put("short", BsonInt32(89))
                    put("list", BsonArray(listOf(BsonSymbol("‡"), BsonSymbol("↪"), BsonSymbol("@"), BsonSymbol("$"))))
                })
                put("$", BsonDocument().apply {
                    put("short", BsonInt32(90))
                    put("list", BsonArray(listOf(BsonSymbol("!"), BsonSymbol("?"), BsonSymbol("~"), BsonSymbol("="))))
                })
            })
        })

        put("listOfMaps", BsonArray(
                listOf(
                        BsonDocument().apply {
                            put("40", BsonArray(listOf(BsonInt32(31), BsonInt32(32), BsonInt32(33), BsonInt32(34), BsonInt32(35))))
                            put("41", BsonArray(listOf(BsonInt32(31), BsonInt32(32), BsonInt32(33), BsonInt32(34), BsonInt32(35))))
                        },
                        BsonDocument().apply {
                            put("40", BsonArray(listOf(BsonInt32(1), BsonInt32(3), BsonInt32(3), BsonInt32(4), BsonInt32(5))))
                            put("41", BsonArray(listOf(BsonInt32(31), BsonInt32(32), BsonInt32(33), BsonInt32(34), BsonInt32(35))))
                        },
                        BsonDocument().apply {
                            put("40", BsonArray(listOf(BsonInt32(0), BsonInt32(0), BsonInt32(1), BsonInt32(4), BsonInt32(5))))
                            put("41", BsonArray(listOf(BsonInt32(31), BsonInt32(32), BsonInt32(33), BsonInt32(34), BsonInt32(35))))
                        },
                        BsonDocument().apply {
                            put("40", BsonArray(listOf(BsonInt32(11), BsonInt32(31), BsonInt32(31), BsonInt32(41), BsonInt32(51))))
                            put("41", BsonArray(listOf(BsonInt32(31), BsonInt32(32), BsonInt32(33), BsonInt32(34), BsonInt32(35))))
                        },
                        BsonDocument().apply {
                            put("44", BsonArray(listOf(BsonInt32(1), BsonInt32(33), BsonInt32(33), BsonInt32(44), BsonInt32(55))))
                            put("41", BsonArray(listOf(BsonInt32(31), BsonInt32(32), BsonInt32(33), BsonInt32(34), BsonInt32(35))))
                        }

                )))
    }

    @Test
    fun simpleDocStringify() {
        assertEquals(simpleDoc, kBson.stringify(Simple.serializer(), simpleModel))
    }

    @Test
    fun simpleDocParseTest() {
        val res = kBson.parse(Simple.serializer(), simpleDoc)
        print("simpleModel $res")
        assertEquals(simpleModel, res)
    }

    @Test
    fun nestedParse() {
        val res = kBson.parse(Nested.serializer(), nestedDoc)
        assertEquals(nestedModel, res)
    }

    @Test
    fun nestedStringify() {
        val d = nestedDoc
        val res = kBson.stringify(Nested.serializer(), nestedModel)
        assertEquals(d, res)
    }

    @Test
    fun complexStringify() {
        val expected = complexDoc
        val actual = kBson.stringify(Complex.serializer(), complexModel)
        assertEquals(expected, actual)
    }

    @Test
    fun complexParse() {
        val result = kBson.parse(Complex.serializer(), complexDoc)
        assertEquals(complexModel, result)
    }

    @Test
    fun nestedComplex() {
        val result: NestedComplex = kBson.parse(
                NestedComplex.serializer(),
                nestedComplexDoc
        )
        assertEquals(nestedComplex, result)
    }

    @Test
    fun nestedComplexStringify() {
        val result = kBson.stringify(NestedComplex.serializer(), nestedComplex)
        assertEquals(nestedComplexDoc, result)
    }

    @Test
    fun nestedComplexStringifyAndParse() {
        val tmp = kBson.stringify(NestedComplex.serializer(), nestedComplex)
        val result: NestedComplex = kBson.parse(NestedComplex.serializer(), tmp)
        assertEquals(nestedComplex, result)
    }

    @Test
    fun customTypesStringify() {
        val custom = Custom(ObjectId("5d17ab793b4083d41f829821"), BigDecimal("3.14"))
        val actual = kBson.stringify(Custom.serializer(), custom)
        val expectedCustomDoc = BsonDocument().apply {
            put("_id", BsonObjectId(ObjectId("5d17ab793b4083d41f829821")))
            put("dec128", BsonDecimal128(Decimal128(BigDecimal("3.14"))))
        }
        assertEquals(
                expectedCustomDoc,
                actual
        )
    }

    @Test
    fun customTypesParse() {
        val expectedCustom = Custom(ObjectId("5d17ab793b4083d41f829821"), BigDecimal("3.14"))

        val customBsonDoc = BsonDocument().apply {
            put("_id", BsonObjectId(ObjectId("5d17ab793b4083d41f829821")))
            put("dec128", BsonDecimal128(Decimal128(BigDecimal("3.14"))))
        }

        val actualCustom = kBson.parse(Custom.serializer(), customBsonDoc)

        assertEquals(
                expectedCustom,
                actualCustom
        )
    }

    @Test
    fun blobStringify() {
        assertEquals(
                kBson.stringify(Blob.serializer(), blobModel),
                blobDoc
        )
    }

    @Test
    fun blobParse() {
        val expectedResult = blobModel
        val result = kBson.parse(Blob.serializer(), blobDoc)
        assertTrue(
                Arrays.equals(expectedResult.img, result.img) &&
                        Arrays.equals(expectedResult.txt, result.txt) &&
                        Arrays.equals(expectedResult.zipFile, result.zipFile)
        )
    }

    @Test
    fun optionalParse() {
        val badDoc = BsonDocument().apply {
            put("reqString3", BsonString("reqString3"))
        }
        val result = kBson.parse(OptionalClass.serializer(), badDoc)
        assertTrue(
                (result.reqString == "default_value1") &&
                        (result.reqString3 == "reqString3")
        )
    }

    @Test
    fun optionalStringify() {
        val data = OptionalClass(reqString3 = "foo")

        val doc = BsonDocument().apply {
            put("reqString", BsonString("default_value1"))
            put("reqString3", BsonString("foo"))
        }
        val result = kBson.stringify(OptionalClass.serializer(), data)
        assertEquals(doc, result)
    }

    @Test
    fun exceptionsMissingValue() {
        val docBadType = BsonDocument()

        try {
            kBson.parse(SimpleNG.serializer(), docBadType)
        } catch (e: MissingFieldException) {
            assertTrue(e.message == "Field 'short' is required, but it was missing")
        }
    }

    @Test
    fun exceptionsBadType() {
        val docBadType = BsonDocument().apply {
            put("short", BsonString("127"))
        }

        try {
            kBson.parse(SimpleNG.serializer(), docBadType)
        } catch (e: BsonInvalidOperationException) {
            assertTrue(e.message == "Value expected to be of type INT32 is of unexpected type STRING")
        }
    }

    @Test
    fun nullParseTest() {
        val docNullableField = BsonDocument().apply {
            put("str", BsonNull())
        }
        val docField = BsonDocument().apply {
            put("str", BsonString("exist"))
        }

        val result1 = kBson.parse(NullableClass.serializer(), docNullableField)
        val result2 = kBson.parse(NullableClass.serializer(), docField)
        assertTrue(result1.str == null && result2.str == "exist")
    }

    @Test
    fun nullStringifyTest() {
        val docNullableField = BsonDocument().apply {
            put("str", BsonNull())
        }

        val modelNullableField = NullableClass(null)

        val docField = BsonDocument().apply {
            put("str", BsonString("exist"))
        }

        val modelField = NullableClass("exist")

        val result1 = kBson.stringify(NullableClass.serializer(), modelNullableField)
        val result2 = kBson.stringify(NullableClass.serializer(), modelField)

        assert(
                docNullableField.equals(result1) &&
                        docField.equals(result2)
        )
    }

    @Test
    fun maps() {
        val foo = Foo(
                key_A = mapOf("a" to "a", "b" to "b", "c" to "c", "d" to "d", "e" to "e"),
                key_B = mapOf("a" to "a", "b" to "b", "c" to "c", "d" to "d", "e" to "e"))

        val doc = BsonDocument().apply {
            put("key_A", BsonDocument().apply {
                put("a", BsonString("a"))
                put("b", BsonString("b"))
                put("c", BsonString("c"))
                put("d", BsonString("d"))
                put("e", BsonString("e"))
            })
            put("key_B", BsonDocument().apply {
                put("a", BsonString("a"))
                put("b", BsonString("b"))
                put("c", BsonString("c"))
                put("d", BsonString("d"))
                put("e", BsonString("e"))
            })
        }
        val result = kBson.parse(Foo.serializer(), doc)
        assertEquals(foo, result)
    }

    @Test
    fun enumStringify() {
        val model = EnumFoo(
                sex = SEX.FEMALE,
                sex2 = SexWithValue.TRANSGENDER
        )

        val result = kBson.stringify(EnumFoo.serializer(), model)

        assertEquals(BsonDocument().apply {
            put("sex", BsonString("FEMALE"))
            put("sex2", BsonString("TRANSGENDER"))
        }, result)
    }

    @Test
    fun enumParse() {
        val model = EnumFoo(
                sex = SEX.FEMALE,
                sex2 = SexWithValue.TRANSGENDER
        )

        val doc = BsonDocument().apply {
            put("sex", BsonString("FEMALE"))
            put("sex2", BsonString("TRANSGENDER"))
        }
        val result = kBson.parse(EnumFoo.serializer(), doc)
        assertEquals(result, model)
    }

    @Test
    fun enumParseException() {
        val doc = BsonDocument().apply {
            put("sex", BsonString("FEMALE"))
            put("sex2", BsonString("AGENDER"))
        }

        try {
            kBson.parse(EnumFoo.serializer(), doc)
        } catch (e: SerializationException) {
            assertEquals("Enum has unknown value AGENDER", e.message)
        }
    }
}
